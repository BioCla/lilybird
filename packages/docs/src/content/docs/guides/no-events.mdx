---
title: Understanding the no-events approach
description: Learn and understand the approach taken by lilybird.
---

As you might have noticed by now lilybird does not have an events api and you might be questioning this decision so lets discuss the motivation behind this.

The main motivation behind not having events is performance, event emitters are really bad when it comes to high throughput and are really easy for the user to misuse them and cause memory leaks so to avoid this issues we went with the same approach `uws` and for that matter `bun` use for their Websocket Server, callbacks.

You might be wondering, "so how can i listen to events or even collect message components?".

Let me answer that for you, usually its rly unlikely that you need to listen to an event more than once and if you really need to you can always just make multiple functions and call them from the same listeners, like so:

```ts
import { createClient, Intents, Interaction } from "lilybird"

function useInteraction1(interaction: Interaction) {
  console.log(interaction.token);
}

function useInteraction2(interaction: Interaction) {
  console.log(interaction.data);
}

await createClient({
  token: process.env.TOKEN,
  intents: [Intents.GUILDS],
  listeners: {
    interactionCreate: (interaction) => {
      useInteraction1(interaction);
      useInteraction2(interaction);
    }
  }
})
```

As for collecting message components, im currently working on an api for collectors that i will try to make as extensible as possible so this should not be an issue once lilybird has its first stable release.